/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package TwistingCrystal;

import processing.core.*;
import processing.event.MouseEvent;
import processing.opengl.PShader;

public class App extends PApplet {
    public static void main(String[] args) {
        PApplet.main("TwistingCrystal.App");
    }

    PShader shader;

    Axes axes;
    Crystal mainCrystal;
    float scale;
    int verticesNum = 100;

    public void settings() {
        size(800, 800, "processing.opengl.PGraphics3D");
    }

    public void setup() {
        shader = loadShader("./data/neon.glsl");

        axes = new Axes();
        mainCrystal = new Crystal(-800, -50, -50, 1600, 100, 100, 
                                PI, verticesNum, PI, PI / 60);
        scale = 1;
    }

    public void draw() {
        background(0);
        shader(shader);
        lights();
        directionalLight(255, 255, 127, 0, 1, 0);
        directionalLight(255, 255, 127, 0, -1, 0);
        mouseControl();
        keyControl();

        drawAll();
    }

    private void drawAll() {
        translate(width / 2, height / 2, 0);

        translate(axes.x, axes.y, axes.z);
        rotateX(axes.rx);
        rotateY(axes.ry);
        rotateZ(axes.rz);
        scale(scale);

        drawAxes();
        drawCrystal(mainCrystal);
    }

    private void drawCrystal(Crystal crystal) {
        noStroke();
        fill(172);

        for (int vertexIndex = 0; vertexIndex < verticesNum; vertexIndex++) {
            for (int cornerIndex = 0; cornerIndex < 4; cornerIndex++) {
                beginShape();
                PVector vertex1 = crystal.getVertices(vertexIndex, cornerIndex);
                vertex(vertex1.x, vertex1.y, vertex1.z);
                PVector vertex2 = crystal.getVertices(vertexIndex, cornerIndex + 1);
                vertex(vertex2.x, vertex2.y, vertex2.z);
                PVector vertex3 = crystal.getVertices(vertexIndex + 1, cornerIndex + 1);
                vertex(vertex3.x, vertex3.y, vertex3.z);
                PVector vertex4 = crystal.getVertices(vertexIndex + 1, cornerIndex);
                vertex(vertex4.x, vertex4.y, vertex4.z);
                endShape(CLOSE);
            }
        }

        crystal.updateCrystal();
    }

    private void drawAxes() {

        int axisLen = 2000;
        strokeWeight(1 / scale);
        
        // x-axis
        stroke(255, 0, 0, 127);
        line(-axisLen / 2, 0, 0, axisLen / 2, 0, 0);

        // y-axis
        stroke(0, 255, 0, 127);
        line(0, -axisLen / 2, 0, 0, axisLen / 2, 0);

        // z-axis
        stroke(0, 0, 255, 127);
        line(0, 0, -axisLen / 2, 0, 0, axisLen / 2);
    }

    public void mouseWheel(MouseEvent e) {
        scale -= e.getCount() * 0.1f;
    }

    private void mouseControl() {

        float dx = mouseX - pmouseX;
        float dy = mouseY - pmouseY;

        if (keyPressed) {
            if (key == 'a') {
                
            }
        } else {
            if (mouseButton == RIGHT) {
                axes.rotateAxes(-dy * 0.01f, dx * 0.01f, 0);
            } else if (mouseButton == LEFT) {
                axes.shiftAxes(dx, dy, 0);
            }
        }
    }

    private void keyControl() {

        if (keyPressed) {
            switch (key) {
                case ' ':
                    axes.initRotate();
                    axes.initShift();
                    break;
                default:
                    break;
            }
        }
    }
}
